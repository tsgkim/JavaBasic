package com.basic.tu;

import org.junit.Test;

/** 
 * Q:用最有效率的方式算出2乘以8等于多少？<br>
 * A: 2<<3   在学习微机原理的时候知道，计算机在计算二进制数的乘除法是通过移位来实现的，把一个二进制数向左移n位就是将这个数乘以2的n次方，
 * 	而这种计算方式是cpu直接支持的，运行速度最快。在java里虽然我们通常使用的是十进制数，但这种方式仍然可行，由于cpu直接支持，所以速度很快。<br><br>
 * 
 * Java 位运算符(只能处理整数运算符)<br><br>
 * 
 * Char、byte、short类型，在进行移位之前，都将被转换成int类型，移位后的结果也是int类型；
 * 移位符号右边的操作数只截取其二进制的后5位（目的是防止因为移位操作而超出int类型的表示范围：2的5次方是32，int类型的最大范围是32位）；
 * 对long类型进行移位，结果仍然是long类型，移位符号右边的操作符只截取其二进制的后6位。<br><br>
 * 
 * 假设整数变量A的值为60(0011 1100)<br>
 * ~	按位补运算符翻转操作数的每一位，即0变成1，1变成0	    ~A 得到-61，即1100 0011<br>  
 * << 	按位左移运算符   左操作数按位左移右操作数指定的位数	A << 2得到240，即 1111 0000 ==>进制数向左移n位就是将这个数乘以2的n次方<br>
 * >> 	按位右移运算符(带符号右移位运算符， 若符号位为正，则在最高位插入0；若符号位为负，则在最高位插入1)   左操作数按位右移右操作数指定的位数  	A >> 2得到15即 1111 ==>进制数向右移n位就是将这个数除以2的n次方<br>
 * >>> 	按位右移补零操作符(无符号右移，无论正负，都在最高位插入0)   左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充	A>>>2得到15即0000 1111<br><br>
 * 
 * 
 * @author 涂世广 
 * @qq 1515503123
 * @date 2017年6月4日 下午1:37:33 
*/
public class Tu_5_Operator {

	@Test
	public void testOperator() {
		Integer A = 240;
		System.out.println("60转换为二进制数位：" + Integer.toBinaryString(A));
		System.out.println("60通过~结果为：" + (~A));
		System.out.println("60通过<<结果为：" + (A << 2));
		System.out.println("60通过>>结果为：" + (A >> 2));
        System.out.println("60通过 >> 1结果为：" + (A >> 1));
        System.out.println("60通过>>>结果为：" + (A >> 2));
		System.out.println("60通过>>>结果为：" + (A >>> 2));
	}

}
